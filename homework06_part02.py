# Marco Gonzalez
# CS 3035 - 01

from functools import reduce

# -------------------------------------------------------------------------------
# GENERAL DIRECTIONS, PLEASE READ CAREFULLY
#
# Part II: Finish the following programming problems by using either map(), filter(),
# reduce(), or a combination of these functions.  If you do not use these functions,
# you will get no credit for this part of the homework.  You may not define any
# other functions for this part of the assignment so you must use lambda functions
# as parameters to filter(), map() or reduce().  You are not allowed to use any loops.
# -------------------------------------------------------------------------------

# -------------------------------------------------------------------------------
# # Q01 (0.25 points):  Finish the my_range function such that it returns a list of values
# generated by taking the input list L and only including values from L that are
# between start and end inclusive.  All the print statement tests that follow
# the function should result in true if your solution is correct.


def my_range(L, start, end):
    # FINISH THIS FUNCTION
    result = filter(lambda n: int(start) - 0.1 < n < int(end) + 0.1, L)
    return list(result)


print("Q01 Output--------------------------------------------------------------")
print(f'{my_range([1,3,4,5,2], 1,3) == [1,3,2] = }')
print(f'{my_range([1,3,4,5,2], 3,1) == [] = }')
print(f'{my_range([1,2,3,4,5], 2,4) == [2,3,4] = }')
print(f'{my_range([1,2,3,4,5], 4,2) == [] = }')
print(f'{my_range([], 0,0) == [] = }')
print(f'{my_range([-1,0,1,2,3], -1, 1 ) == [-1,0,1] = }')
print(f'{my_range([1.1,2.2,3.3,4.4,5.5], 2.1, 5.2 ) == [2.2,3.3,4.4] = }')
print(f'{my_range([1.1,2.2,3.3,4.4,5.5], 5.2, 2.1 ) == [] = }')
print("-----------------------------------------------------------------------\n\n")
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Q02 (0.25 points) Implement the function one_dim_list to transform the given
# two-dimensional list into a one-dimensional list where the values appear in
# the same order.  The function should return the resulting list.  HINT: Remember
# that you can concatenate two lists in python using the + operator. All the
# print statement tests that follow the function should result in True if your
# solution is correct.


def one_dim_list(list2d):
    # FINISH THIS FUNCTION
    result = reduce(lambda x, y: x + y, list2d)
    return list(result)


print("Q02 Output--------------------------------------------------------------")
print(f'{one_dim_list([[]]) == [] =}')
print(f'{one_dim_list([[2,3]]) == [2,3] = } ')
print(f'{one_dim_list([[1,2,3], [], [0], [4,5]]) == [1,2,3,0,4,5] = } ')
print(f'{one_dim_list([[1,2,3], [], [4], [5,6]]) == [1,2,3,4,5,6] = } ')
print(f"{one_dim_list([[], ['e','d'], ['a','b','c']]) == ['e','d','a','b','c'] = } ")
print(f'{one_dim_list([[1,2,3], [4,5], [6], [], [7,8,9], []]) == [1,2,3,4,5,6,7,8,9] = } ')
print("-----------------------------------------------------------------------\n\n")
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Q03: Implement the multi_sum method to find the sum of each "row" of the 2D list
# given as a parameter.  Each sum should be returned in a list of the sums. All
# the print statement tests that follow the function should result in True if
# your solution is correct.  For this one, it is OK to use the builtin sum() function.


def multi_sum(list2d):
    # FINISH THIS FUNCTION
    result = map(sum, list2d)
    return list(result)


print("Q03 Output--------------------------------------------------------------")
print(f'{multi_sum([[1,2], [3,4]]) == [3,7] =}')
print(f'{multi_sum([[],[],[1]]) == [0,0,1] =}')
print(f'{multi_sum([[]]) == [0] =}')
print(f'{multi_sum([[1,2,3],[2,2,2],[3,3,3]]) == [6,6,9] =}')
print("-----------------------------------------------------------------------\n\n")

# ------------------------------------------------------------------------------
# Q04 (0.25 points) Finish the my_min function such that it returns the second smallest
# value in the input list L.  If the list contains duplicates, the second smallest
# number and the smallest number may be identical. All the print statement tests
# that follow the function should result in True if your solution is correct.


def my_min(L):
    # FINISH THIS FUNCTION.

    # This was my initial implementation without using lambda()
    # first_lowest = reduce(min, L)
    # L.remove(first_lowest)
    # second_lowest = reduce(min, L)
    # return second_lowest

    # This is my second implementation using lambda()
    # first_lowest = reduce(lambda x, y: x if x < y else y, L)
    # L.remove(first_lowest)
    # second_lowest = reduce(lambda x, y: x if x < y else y, L)
    # return second_lowest

    # Final implementation without using remove() or min()
    sorted_list = sorted(list(map(lambda x: x, L)))
    result = reduce(lambda x, y: x if x < y else y, sorted_list[1:])
    return result


print("Q04 Output--------------------------------------------------------------")
print(f'{my_min([2110, 4820, 3110, 4120]) == 3110 = }')
print(f'{my_min([2110, 4820, 2110, 4120]) == 2110 = }')
print(f'{my_min([1.2, 2.3, 1.2, 1.2]) == 1.2 = }')
print("-----------------------------------------------------------------------\n\n")
# ------------------------------------------------------------------------------
